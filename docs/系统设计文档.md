# 德州扑克系统设计文档（现金赛模式）

## 目录
1. [项目概述](#1-项目概述)
2. [系统架构](#2-系统架构)
3. [核心模块设计](#3-核心模块设计)
4. [数据库设计](#4-数据库设计)
5. [开发阶段规划](#5-开发阶段规划)
6. [技术实现细节](#6-技术实现细节)
7. [关键算法](#7-关键算法)

---

## 1. 项目概述

### 1.1 项目背景
开发一个基于Spring Boot + React.js的德州扑克现金赛系统，支持俱乐部管理、赛季制度、实时游戏和统计功能。

### 1.2 核心特性
- **现金赛模式**：筹码等于真实货币，固定盲注，随时买入/离开
- **赛季制度**：按时间周期组织比赛，统计长期盈亏
- **俱乐部管理**：多俱乐部支持，成员权限管理
- **实时游戏**：WebSocket实时通信，公平发牌算法
- **数据统计**：详细的个人和俱乐部统计数据

### 1.3 技术栈
- **后端**：Java 17, Spring Boot 3.2, Spring Data JPA, MySQL 8.0, Liquibase
- **前端**：React 18, WebSocket, CSS3
- **数据库**：MySQL 8.0
- **构建工具**：Maven, npm

---

## 2. 系统架构

### 2.1 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   React前端     │◄──►│  Spring Boot    │◄──►│     MySQL       │
│                 │    │     后端        │    │     数据库      │
│  - 游戏界面     │    │  - REST API     │    │  - 业务数据     │
│  - 管理界面     │    │  - WebSocket    │    │  - 统计数据     │
│  - 统计报表     │    │  - 游戏逻辑     │    │  - 用户数据     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.2 业务层次结构
```
俱乐部（Club）
  ↓
赛季（Season）
  ↓
现金赛桌（Cash Table）
  ↓
游戏局（Game/Hand）
  ↓
玩家行动（Player Actions）
  ↓
结算（Settlement）
```

---

## 3. 核心模块设计

### 3.1 俱乐部管理模块

**功能职责：**
- 俱乐部创建与配置
- 成员邀请与权限管理
- 俱乐部设置管理

**核心实体：**
- `Club`：俱乐部基本信息
- `ClubMember`：成员关系和权限
- `ClubSettings`：俱乐部配置

**主要接口：**
```java
@RestController
@RequestMapping("/api/clubs")
public class ClubController {
    POST /api/clubs - 创建俱乐部
    GET /api/clubs/{id} - 获取俱乐部详情
    POST /api/clubs/{id}/members - 邀请成员
    DELETE /api/clubs/{id}/members/{userId} - 移除成员
}
```

### 3.2 赛季管理模块

**功能职责：**
- 赛季创建与时间管理
- 赛季内赛事组织
- 赛季统计数据汇总

**核心实体：**
- `Season`：赛季基本信息和时间范围
- `SeasonStats`：赛季统计数据

**业务规则：**
- 赛季有明确的开始和结束时间
- 一个俱乐部可以有多个赛季（历史赛季）
- 赛季结束后数据归档，不可修改

### 3.3 现金赛桌管理模块 ⭐

**功能职责：**
- 赛事创建与配置（盲注、买入范围、时长）
- 玩家座位管理
- 筹码买入/补充/兑现
- 赛事时间控制

**核心实体：**
- `CashTable`：现金赛桌配置和状态
- `TablePlayer`：桌上玩家信息
- `ChipTransaction`：筹码交易记录

**关键业务逻辑：**
```java
// 买入验证
public boolean validateBuyin(long amount, long minBuyin, long maxBuyin) {
    return amount >= minBuyin && amount <= maxBuyin;
}

// 补充筹码验证
public boolean validateAddChips(long currentChips, long addAmount, long maxBuyin) {
    return (currentChips + addAmount) <= maxBuyin;
}

// 离桌结算
public CashoutResult cashout(TablePlayer player) {
    long netProfit = player.getCurrentChips() - player.getTotalBuyin();
    // 更新赛季统计
    updateSeasonStats(player, netProfit);
    return new CashoutResult(player.getCurrentChips(), netProfit);
}
```

### 3.4 游戏核心模块 ⭐⭐

**功能职责：**
- 公平随机发牌
- 游戏状态管理
- 下注轮次控制
- 牌型识别与比较
- 底池计算与分配

**核心实体：**
- `Game`：单局游戏信息
- `GamePlayer`：游戏中的玩家状态
- `PlayerAction`：玩家行动记录
- `Deck`：牌库和发牌逻辑
- `Card`：扑克牌

**游戏状态机：**
```
WAITING → DEALING → PRE_FLOP → FLOP → TURN → RIVER → SHOWDOWN → FINISHED
```

**德州扑克规则实现：**

1. **发牌规则**
   - 52张标准扑克牌
   - Fisher-Yates洗牌算法
   - 每人2张底牌 + 5张公共牌
   - 发牌前烧牌（Burn Card）

2. **下注规则**
   - 盲注：小盲、大盲（固定金额）
   - 玩家操作：弃牌、过牌、跟注、下注、加注、全下
   - 最小加注：等于上一次下注/加注金额
   - 底池管理：主池、边池（All-in情况）

3. **牌型规则（从大到小）**
   ```
   1. 皇家同花顺 (Royal Flush)      - A♠K♠Q♠J♠10♠
   2. 同花顺 (Straight Flush)       - 9♥8♥7♥6♥5♥
   3. 四条 (Four of a Kind)         - A♠A♥A♦A♣K♠
   4. 葫芦 (Full House)             - K♠K♥K♦5♠5♥
   5. 同花 (Flush)                  - A♠J♠9♠6♠3♠
   6. 顺子 (Straight)               - A♠K♥Q♦J♠10♥
   7. 三条 (Three of a Kind)        - Q♠Q♥Q♦A♠K♥
   8. 两对 (Two Pair)               - A♠A♥K♠K♦Q♠
   9. 一对 (One Pair)               - A♠A♥K♠Q♦J♠
   10. 高牌 (High Card)             - A♠K♥Q♦J♠9♥
   ```

### 3.5 统计分析模块

**功能职责：**
- 实时统计数据计算
- 历史数据分析
- 排行榜生成
- 报表导出

**统计维度：**
- **个人统计**：胜率、盈亏、VP$IP、PFR等专业指标
- **赛季统计**：赛季盈亏排行、参与度统计
- **俱乐部统计**：整体活跃度、成员表现

---

## 4. 数据库设计

### 4.1 核心表结构

```sql
-- 用户表
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    avatar_url VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 俱乐部表
CREATE TABLE clubs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    avatar_url VARCHAR(255),
    creator_id BIGINT NOT NULL,
    settings JSON,  -- 俱乐部配置
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (creator_id) REFERENCES users(id)
);

-- 俱乐部成员表
CREATE TABLE club_members (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    club_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    role VARCHAR(20) NOT NULL,  -- ADMIN, MEMBER
    status VARCHAR(20) DEFAULT 'ACTIVE',  -- ACTIVE, INACTIVE
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (club_id) REFERENCES clubs(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE KEY unique_club_user (club_id, user_id)
);

-- 赛季表
CREATE TABLE seasons (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    club_id BIGINT NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    status VARCHAR(20) DEFAULT 'UPCOMING',  -- UPCOMING, ACTIVE, FINISHED
    settings JSON,  -- 赛季配置
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (club_id) REFERENCES clubs(id)
);

-- 现金赛桌表
CREATE TABLE cash_tables (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    season_id BIGINT NOT NULL,
    name VARCHAR(100) NOT NULL,
    small_blind INT NOT NULL,
    big_blind INT NOT NULL,
    min_buyin BIGINT NOT NULL,
    max_buyin BIGINT NOT NULL,
    max_seats INT DEFAULT 6,
    duration_minutes INT,  -- 赛事时长（分钟）
    status VARCHAR(20) DEFAULT 'WAITING',  -- WAITING, RUNNING, FINISHED, CANCELLED
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    scheduled_end_time TIMESTAMP,  -- 计划结束时间
    created_by BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (season_id) REFERENCES seasons(id),
    FOREIGN KEY (created_by) REFERENCES users(id)
);

-- 桌上玩家表
CREATE TABLE table_players (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    table_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    seat_position INT NOT NULL,  -- 1-9座位号
    total_buyin BIGINT DEFAULT 0,  -- 总买入金额
    current_chips BIGINT NOT NULL,  -- 当前筹码
    status VARCHAR(20) DEFAULT 'PLAYING',  -- PLAYING, LEFT, SITTING_OUT
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    left_at TIMESTAMP,
    FOREIGN KEY (table_id) REFERENCES cash_tables(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE KEY unique_table_seat (table_id, seat_position),
    UNIQUE KEY unique_table_user (table_id, user_id)
);

-- 筹码交易记录表
CREATE TABLE chip_transactions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    table_player_id BIGINT NOT NULL,
    type VARCHAR(20) NOT NULL,  -- BUYIN, ADDON, CASHOUT
    amount BIGINT NOT NULL,
    balance_before BIGINT NOT NULL,
    balance_after BIGINT NOT NULL,
    description VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (table_player_id) REFERENCES table_players(id)
);

-- 游戏局表
CREATE TABLE games (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    table_id BIGINT NOT NULL,
    hand_number INT NOT NULL,  -- 第几局（从1开始）
    button_position INT NOT NULL,  -- 庄家位置
    small_blind_amount INT NOT NULL,
    big_blind_amount INT NOT NULL,
    status VARCHAR(20) DEFAULT 'DEALING',  -- DEALING, PRE_FLOP, FLOP, TURN, RIVER, SHOWDOWN, FINISHED
    deck_seed VARCHAR(255),  -- 洗牌种子（可验证随机性）
    community_cards VARCHAR(20),  -- 公共牌，如"AS,KH,QD,JC,10S"
    total_pot BIGINT DEFAULT 0,
    rake_amount BIGINT DEFAULT 0,  -- 抽水
    winner_seats VARCHAR(50),  -- 获胜座位，如"1,3"（平分情况）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    finished_at TIMESTAMP,
    FOREIGN KEY (table_id) REFERENCES cash_tables(id)
);

-- 游戏局玩家表
CREATE TABLE game_players (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    game_id BIGINT NOT NULL,
    table_player_id BIGINT NOT NULL,
    seat_position INT NOT NULL,
    hole_cards VARCHAR(10),  -- 底牌（加密存储），如"AS,KH"
    chips_before BIGINT NOT NULL,  -- 本局开始前筹码
    chips_after BIGINT NOT NULL,  -- 本局结束后筹码
    total_bet BIGINT DEFAULT 0,  -- 本局总下注
    net_win BIGINT DEFAULT 0,  -- 本局净盈亏
    final_action VARCHAR(20),  -- 最终行动：FOLD, CALL, RAISE, ALLIN, WIN_BY_FOLD
    hand_strength VARCHAR(50),  -- 最终牌型，如"PAIR_ACES"
    is_winner BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (game_id) REFERENCES games(id),
    FOREIGN KEY (table_player_id) REFERENCES table_players(id)
);

-- 玩家行动记录表
CREATE TABLE player_actions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    game_id BIGINT NOT NULL,
    game_player_id BIGINT NOT NULL,
    round VARCHAR(20) NOT NULL,  -- PRE_FLOP, FLOP, TURN, RIVER
    action_type VARCHAR(20) NOT NULL,  -- FOLD, CHECK, CALL, BET, RAISE, ALLIN
    amount BIGINT DEFAULT 0,  -- 下注金额
    pot_before BIGINT NOT NULL,  -- 行动前底池
    pot_after BIGINT NOT NULL,  -- 行动后底池
    position INT NOT NULL,  -- 行动顺序
    time_taken_seconds INT,  -- 思考时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (game_id) REFERENCES games(id),
    FOREIGN KEY (game_player_id) REFERENCES game_players(id)
);

-- 赛季统计表
CREATE TABLE season_stats (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    season_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    -- 基础数据
    total_buyin BIGINT DEFAULT 0,  -- 总买入
    total_cashout BIGINT DEFAULT 0,  -- 总兑现
    net_profit BIGINT DEFAULT 0,  -- 净盈亏
    -- 参与数据
    sessions_played INT DEFAULT 0,  -- 参与赛事数
    hands_played INT DEFAULT 0,  -- 参与局数
    total_time_minutes INT DEFAULT 0,  -- 总游戏时间
    -- 游戏数据
    hands_won INT DEFAULT 0,  -- 赢的局数
    biggest_win BIGINT DEFAULT 0,  -- 最大单局盈利
    biggest_loss BIGINT DEFAULT 0,  -- 最大单局亏损
    -- 专业指标
    vpip_percentage DECIMAL(5,2) DEFAULT 0,  -- 自愿投入底池百分比
    pfr_percentage DECIMAL(5,2) DEFAULT 0,  -- 翻牌前加注率
    aggression_factor DECIMAL(5,2) DEFAULT 0,  -- 激进因子
    -- 时间戳
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (season_id) REFERENCES seasons(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE KEY unique_season_user (season_id, user_id)
);
```

### 4.2 索引设计

```sql
-- 性能优化索引
CREATE INDEX idx_club_members_club_id ON club_members(club_id);
CREATE INDEX idx_club_members_user_id ON club_members(user_id);
CREATE INDEX idx_seasons_club_id ON seasons(club_id);
CREATE INDEX idx_cash_tables_season_id ON cash_tables(season_id);
CREATE INDEX idx_cash_tables_status ON cash_tables(status);
CREATE INDEX idx_table_players_table_id ON table_players(table_id);
CREATE INDEX idx_table_players_user_id ON table_players(user_id);
CREATE INDEX idx_games_table_id ON games(table_id);
CREATE INDEX idx_games_created_at ON games(created_at);
CREATE INDEX idx_game_players_game_id ON game_players(game_id);
CREATE INDEX idx_player_actions_game_id ON player_actions(game_id);
CREATE INDEX idx_season_stats_season_id ON season_stats(season_id);
CREATE INDEX idx_season_stats_user_id ON season_stats(user_id);
```

---

## 5. 开发阶段规划

### 🎯 第一阶段：核心发牌功能（Week 1-2）

**目标：** 实现可验证的公平随机发牌系统

**技术要点：**
- Fisher-Yates洗牌算法
- SecureRandom随机数生成
- 牌型识别算法
- 前端扑克牌组件

**交付物：**
- ✅ 52张牌的标准牌库
- ✅ 洗牌和发牌逻辑
- ✅ 前端牌桌界面
- ✅ 发牌动画效果
- ✅ 单元测试覆盖

**详细任务：**

**Day 1-2: 数据库基础**
```sql
-- Liquibase changeset
CREATE TABLE games (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    table_id BIGINT,
    hand_number INT,
    button_position INT,
    deck_seed VARCHAR(255),
    community_cards VARCHAR(20),
    status VARCHAR(20),
    created_at TIMESTAMP
);

CREATE TABLE game_players (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    game_id BIGINT,
    seat_position INT,
    hole_cards VARCHAR(10),
    chips_before BIGINT,
    chips_after BIGINT
);
```

**Day 3-5: 后端核心类**
```java
// 扑克牌枚举
public enum Suit {
    SPADE("♠"), HEART("♥"), CLUB("♣"), DIAMOND("♦");
}

public enum Rank {
    TWO(2), THREE(3), FOUR(4), FIVE(5), SIX(6), SEVEN(7), EIGHT(8),
    NINE(9), TEN(10), JACK(11), QUEEN(12), KING(13), ACE(14);
}

// 扑克牌类
public class Card {
    private final Suit suit;
    private final Rank rank;
    
    public String getDisplayName() {
        return rank.getSymbol() + suit.getSymbol();
    }
}

// 牌库类
public class Deck {
    private List<Card> cards;
    private SecureRandom random;
    
    public void shuffle() {
        // Fisher-Yates洗牌算法
        for (int i = cards.size() - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            Collections.swap(cards, i, j);
        }
    }
    
    public Card dealCard() {
        if (cards.isEmpty()) {
            throw new IllegalStateException("牌库已空");
        }
        return cards.remove(0);
    }
}

// 游戏类
@Entity
public class Game {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long tableId;
    private int handNumber;
    private int buttonPosition;
    private String deckSeed;  // 洗牌种子
    private String communityCards;  // JSON格式存储
    
    @Enumerated(EnumType.STRING)
    private GameStatus status;
    
    @OneToMany(mappedBy = "game", cascade = CascadeType.ALL)
    private List<GamePlayer> players;
}
```

**Day 6-8: 前端组件**
```javascript
// 扑克牌组件
const Card = ({ suit, rank, isHidden = false }) => {
  const suitSymbols = {
    'SPADE': '♠', 'HEART': '♥', 'CLUB': '♣', 'DIAMOND': '♦'
  };
  
  const isRed = suit === 'HEART' || suit === 'DIAMOND';
  
  return (
    <div className={`card ${isRed ? 'red' : 'black'} ${isHidden ? 'hidden' : ''}`}>
      {!isHidden && (
        <>
          <span className="rank">{rank}</span>
          <span className="suit">{suitSymbols[suit]}</span>
        </>
      )}
    </div>
  );
};

// 牌桌组件
const PokerTable = () => {
  const [communityCards, setCommunityCards] = useState([]);
  const [players, setPlayers] = useState([]);
  
  return (
    <div className="poker-table">
      <div className="community-area">
        <h3>公共牌</h3>
        <div className="community-cards">
          {communityCards.map((card, index) => (
            <Card key={index} {...card} />
          ))}
        </div>
      </div>
      
      <div className="players-area">
        {players.map(player => (
          <PlayerSeat key={player.id} player={player} />
        ))}
      </div>
    </div>
  );
};
```

**Day 9-10: 测试与集成**
```java
@Test
public void testShuffleRandomness() {
    Deck deck1 = new Deck();
    Deck deck2 = new Deck();
    
    deck1.shuffle();
    deck2.shuffle();
    
    // 验证两次洗牌结果不同
    assertNotEquals(deck1.getCards(), deck2.getCards());
}

@Test
public void testDealCards() {
    Deck deck = new Deck();
    deck.shuffle();
    
    // 发2张底牌给6个玩家
    for (int i = 0; i < 6; i++) {
        Card card1 = deck.dealCard();
        Card card2 = deck.dealCard();
        assertNotNull(card1);
        assertNotNull(card2);
        assertNotEquals(card1, card2);
    }
    
    // 验证剩余牌数
    assertEquals(40, deck.getRemainingCards());
}
```

---

### 🎯 第二阶段：结算功能（Week 3-4）

**目标：** 实现完整的牌型识别和结算系统

**技术要点：**
- 牌型识别算法（从7张牌中选最佳5张）
- 牌型比较逻辑
- 底池分配算法
- 边池处理（All-in情况）

**核心算法：**
```java
// 牌型识别
public class HandEvaluator {
    
    public HandRank evaluateHand(List<Card> allCards) {
        // 从7张牌中选择最佳5张牌组合
        List<List<Card>> combinations = generateCombinations(allCards, 5);
        HandRank bestHand = null;
        
        for (List<Card> combo : combinations) {
            HandRank hand = evaluateFiveCards(combo);
            if (bestHand == null || hand.compareTo(bestHand) > 0) {
                bestHand = hand;
            }
        }
        return bestHand;
    }
    
    private HandRank evaluateFiveCards(List<Card> cards) {
        if (isRoyalFlush(cards)) return new HandRank(ROYAL_FLUSH, cards);
        if (isStraightFlush(cards)) return new HandRank(STRAIGHT_FLUSH, cards);
        if (isFourOfAKind(cards)) return new HandRank(FOUR_OF_A_KIND, cards);
        if (isFullHouse(cards)) return new HandRank(FULL_HOUSE, cards);
        if (isFlush(cards)) return new HandRank(FLUSH, cards);
        if (isStraight(cards)) return new HandRank(STRAIGHT, cards);
        if (isThreeOfAKind(cards)) return new HandRank(THREE_OF_A_KIND, cards);
        if (isTwoPair(cards)) return new HandRank(TWO_PAIR, cards);
        if (isOnePair(cards)) return new HandRank(ONE_PAIR, cards);
        return new HandRank(HIGH_CARD, cards);
    }
}

// 底池分配
public class PotManager {
    
    public List<PotResult> distributePots(List<GamePlayer> players, long totalPot) {
        List<PotResult> results = new ArrayList<>();
        
        // 按投入筹码排序，处理边池
        players.sort(Comparator.comparing(GamePlayer::getTotalBet));
        
        long remainingPot = totalPot;
        int eligiblePlayers = players.size();
        
        for (int i = 0; i < players.size(); i++) {
            GamePlayer player = players.get(i);
            long playerBet = player.getTotalBet();
            
            if (i > 0) {
                long prevBet = players.get(i - 1).getTotalBet();
                playerBet -= prevBet;
            }
            
            long sidePot = playerBet * eligiblePlayers;
            
            // 找出该边池的获胜者
            List<GamePlayer> eligibleForThisPot = players.subList(i, players.size());
            List<GamePlayer> winners = findWinners(eligibleForThisPot);
            
            // 分配边池
            long winPerPlayer = sidePot / winners.size();
            for (GamePlayer winner : winners) {
                results.add(new PotResult(winner, winPerPlayer));
            }
            
            remainingPot -= sidePot;
            eligiblePlayers--;
        }
        
        return results;
    }
}
```

---

### 🎯 第三阶段：牌局管理（Week 5-6）

**目标：** 实现完整的游戏流程控制

**技术要点：**
- 游戏状态机
- 下注轮次管理
- 玩家操作验证
- WebSocket实时通信

**状态机实现：**
```java
@Component
public class GameStateMachine {
    
    public void processPlayerAction(Long gameId, Long playerId, PlayerAction action) {
        Game game = gameRepository.findById(gameId);
        
        // 验证操作合法性
        validateAction(game, playerId, action);
        
        // 执行操作
        executeAction(game, playerId, action);
        
        // 检查是否需要状态转换
        checkStateTransition(game);
        
        // 广播状态更新
        broadcastGameState(game);
    }
    
    private void checkStateTransition(Game game) {
        switch (game.getStatus()) {
            case PRE_FLOP:
                if (allPlayersActed(game)) {
                    dealFlop(game);
                    game.setStatus(GameStatus.FLOP);
                }
                break;
            case FLOP:
                if (allPlayersActed(game)) {
                    dealTurn(game);
                    game.setStatus(GameStatus.TURN);
                }
                break;
            // ... 其他状态转换
        }
    }
}
```

---

### 🎯 第四阶段：赛事管理（Week 7-8）

**目标：** 实现现金赛桌的完整生命周期

**技术要点：**
- 赛事创建与配置
- 玩家买入/补充/离桌
- 时间控制与自动结束
- 筹码交易记录

**核心业务逻辑：**
```java
@Service
public class CashTableService {
    
    public CashTable createTable(CreateTableRequest request) {
        // 验证创建权限
        validateCreatePermission(request.getCreatorId(), request.getSeasonId());
        
        CashTable table = new CashTable();
        table.setSeasonId(request.getSeasonId());
        table.setName(request.getName());
        table.setSmallBlind(request.getSmallBlind());
        table.setBigBlind(request.getBigBlind());
        table.setMinBuyin(request.getMinBuyin());
        table.setMaxBuyin(request.getMaxBuyin());
        table.setDurationMinutes(request.getDurationMinutes());
        table.setStatus(TableStatus.WAITING);
        
        return cashTableRepository.save(table);
    }
    
    public TablePlayer joinTable(Long tableId, Long userId, long buyinAmount) {
        CashTable table = findById(tableId);
        
        // 验证买入金额
        if (buyinAmount < table.getMinBuyin() || buyinAmount > table.getMaxBuyin()) {
            throw new IllegalArgumentException("买入金额不在允许范围内");
        }
        
        // 检查座位
        int availableSeat = findAvailableSeat(tableId);
        if (availableSeat == -1) {
            throw new IllegalStateException("没有可用座位");
        }
        
        // 创建玩家记录
        TablePlayer player = new TablePlayer();
        player.setTableId(tableId);
        player.setUserId(userId);
        player.setSeatPosition(availableSeat);
        player.setTotalBuyin(buyinAmount);
        player.setCurrentChips(buyinAmount);
        player.setStatus(PlayerStatus.PLAYING);
        
        TablePlayer savedPlayer = tablePlayerRepository.save(player);
        
        // 记录买入交易
        recordTransaction(savedPlayer.getId(), TransactionType.BUYIN, buyinAmount, 0, buyinAmount);
        
        return savedPlayer;
    }
    
    @Scheduled(fixedRate = 60000)  // 每分钟检查
    public void checkTableTimeouts() {
        List<CashTable> runningTables = cashTableRepository.findByStatus(TableStatus.RUNNING);
        
        for (CashTable table : runningTables) {
            if (LocalDateTime.now().isAfter(table.getScheduledEndTime())) {
                endTable(table.getId());
            }
        }
    }
}
```

---

### 🎯 第五阶段：俱乐部管理（Week 9-10）

**目标：** 完善俱乐部和赛季管理功能

**技术要点：**
- 俱乐部权限管理
- 赛季创建与配置
- 成员邀请与审批
- 数据统计与报表

---

### 🎯 第六阶段：统计与优化（Week 11-12）

**目标：** 完善统计功能和系统优化

**技术要点：**
- 实时统计计算
- 历史数据分析
- 性能优化
- 安全加固

---

## 6. 技术实现细节

### 6.1 随机性保证

**洗牌算法：**
```java
public class SecureDeck {
    private static final SecureRandom SECURE_RANDOM = new SecureRandom();
    
    public void shuffle(String seed) {
        // 使用时间戳 + 用户提供的种子
        long timestamp = System.currentTimeMillis();
        String combinedSeed = timestamp + "_" + seed;
        
        // 设置随机种子
        SECURE_RANDOM.setSeed(combinedSeed.hashCode());
        
        // Fisher-Yates洗牌
        for (int i = cards.size() - 1; i > 0; i--) {
            int j = SECURE_RANDOM.nextInt(i + 1);
            Collections.swap(cards, i, j);
        }
        
        // 记录种子用于验证
        this.deckSeed = combinedSeed;
    }
}
```

### 6.2 WebSocket实时通信

**后端配置：**
```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new GameWebSocketHandler(), "/ws/game/{tableId}")
                .setAllowedOrigins("*");
    }
}

@Component
public class GameWebSocketHandler extends TextWebSocketHandler {
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        String tableId = extractTableId(session);
        sessionManager.addSession(tableId, session);
    }
    
    public void broadcastToTable(Long tableId, GameStateUpdate update) {
        List<WebSocketSession> sessions = sessionManager.getTableSessions(tableId);
        String message = objectMapper.writeValueAsString(update);
        
        for (WebSocketSession session : sessions) {
            if (session.isOpen()) {
                session.sendMessage(new TextMessage(message));
            }
        }
    }
}
```

**前端连接：**
```javascript
class GameWebSocket {
    constructor(tableId, onMessage) {
        this.tableId = tableId;
        this.onMessage = onMessage;
        this.connect();
    }
    
    connect() {
        this.ws = new WebSocket(`ws://localhost:8080/ws/game/${this.tableId}`);
        
        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.onMessage(data);
        };
        
        this.ws.onclose = () => {
            // 重连逻辑
            setTimeout(() => this.connect(), 3000);
        };
    }
    
    sendAction(action) {
        if (this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(action));
        }
    }
}
```

### 6.3 数据安全

**底牌加密：**
```java
@Component
public class CardEncryption {
    
    @Value("${poker.card.encryption.key}")
    private String encryptionKey;
    
    public String encryptHoleCards(List<Card> cards) {
        String cardString = cards.stream()
            .map(Card::toString)
            .collect(Collectors.joining(","));
        
        return AESUtil.encrypt(cardString, encryptionKey);
    }
    
    public List<Card> decryptHoleCards(String encrypted) {
        String cardString = AESUtil.decrypt(encrypted, encryptionKey);
        return Arrays.stream(cardString.split(","))
            .map(Card::fromString)
            .collect(Collectors.toList());
    }
}
```

---

## 7. 关键算法

### 7.1 牌型识别算法

```java
public class HandRankCalculator {
    
    // 快速牌型识别（使用位运算优化）
    public HandRank calculateHandRank(List<Card> sevenCards) {
        // 转换为位表示
        long suits = 0;
        long ranks = 0;
        
        for (Card card : sevenCards) {
            suits |= (1L << (card.getSuit().ordinal() * 13 + card.getRank().getValue()));
            ranks |= (1L << card.getRank().getValue());
        }
        
        // 检查同花
        boolean isFlush = checkFlush(suits);
        
        // 检查顺子
        boolean isStraight = checkStraight(ranks);
        
        if (isFlush && isStraight) {
            return checkStraightFlush(sevenCards);
        }
        
        // 检查对子、三条、四条
        return checkPairs(sevenCards);
    }
    
    private boolean checkFlush(long suits) {
        // 检查是否有5张或以上同花色
        for (int suit = 0; suit < 4; suit++) {
            long suitMask = suits & (0x1FFFL << (suit * 13));
            if (Long.bitCount(suitMask) >= 5) {
                return true;
            }
        }
        return false;
    }
    
    private boolean checkStraight(long ranks) {
        // 检查连续5张牌
        // A-2-3-4-5 (wheel)
        if ((ranks & 0x100F) == 0x100F) return true;
        
        // 其他顺子
        for (int i = 0; i <= 8; i++) {
            if ((ranks & (0x1F << i)) == (0x1F << i)) {
                return true;
            }
        }
        return false;
    }
}
```

### 7.2 底池分配算法

```java
public class PotDistribution {
    
    public List<WinResult> distributePot(List<GamePlayer> players) {
        // 按投入金额排序
        players.sort(Comparator.comparing(GamePlayer::getTotalBet));
        
        List<SidePot> sidePots = createSidePots(players);
        List<WinResult> results = new ArrayList<>();
        
        for (SidePot pot : sidePots) {
            List<GamePlayer> winners = findWinners(pot.getEligiblePlayers());
            long winPerPlayer = pot.getAmount() / winners.size();
            long remainder = pot.getAmount() % winners.size();
            
            // 分配底池，余数给位置靠前的玩家
            for (int i = 0; i < winners.size(); i++) {
                long winAmount = winPerPlayer + (i < remainder ? 1 : 0);
                results.add(new WinResult(winners.get(i), winAmount));
            }
        }
        
        return results;
    }
    
    private List<SidePot> createSidePots(List<GamePlayer> sortedPlayers) {
        List<SidePot> sidePots = new ArrayList<>();
        long prevBet = 0;
        
        for (int i = 0; i < sortedPlayers.size(); i++) {
            GamePlayer player = sortedPlayers.get(i);
            long currentBet = player.getTotalBet();
            long betDiff = currentBet - prevBet;
            
            if (betDiff > 0) {
                long potAmount = betDiff * (sortedPlayers.size() - i);
                List<GamePlayer> eligible = sortedPlayers.subList(i, sortedPlayers.size());
                sidePots.add(new SidePot(potAmount, eligible));
            }
            
            prevBet = currentBet;
        }
        
        return sidePots;
    }
}
```

---

## 8. 部署与运维

### 8.1 环境配置

**生产环境配置：**
```yaml
# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://prod-db:3306/poker_db?useSSL=true&serverTimezone=UTC
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
  
  liquibase:
    change-log: classpath:db/changelog/db.changelog-master.xml

poker:
  card:
    encryption:
      key: ${CARD_ENCRYPTION_KEY}
  websocket:
    allowed-origins: ${ALLOWED_ORIGINS}
  
logging:
  level:
    com.poker: INFO
    org.springframework.web: WARN
```

### 8.2 监控指标

**关键监控指标：**
- 游戏局数/小时
- 平均游戏时长
- WebSocket连接数
- 数据库连接池使用率
- 内存使用情况
- 发牌随机性验证

---

## 9. 测试策略

### 9.1 单元测试

**核心算法测试：**
```java
@Test
public void testHandRankComparison() {
    // 皇家同花顺 vs 同花顺
    HandRank royalFlush = HandRank.royalFlush(Suit.SPADE);
    HandRank straightFlush = HandRank.straightFlush(Suit.HEART, Rank.NINE);
    
    assertTrue(royalFlush.compareTo(straightFlush) > 0);
}

@Test
public void testPotDistribution() {
    // 测试边池分配
    List<GamePlayer> players = Arrays.asList(
        createPlayer(1, 100, HandRank.pair(Rank.ACE)),
        createPlayer(2, 50, HandRank.pair(Rank.KING)),
        createPlayer(3, 100, HandRank.pair(Rank.ACE))
    );
    
    List<WinResult> results = potDistribution.distributePot(players);
    
    // 验证分配结果
    assertEquals(2, results.size());
    assertEquals(75, results.get(0).getAmount()); // 主池平分
    assertEquals(75, results.get(1).getAmount());
}
```

### 9.2 集成测试

**完整游戏流程测试：**
```java
@SpringBootTest
@Transactional
public class GameIntegrationTest {
    
    @Test
    public void testCompleteGameFlow() {
        // 1. 创建赛事
        CashTable table = createTestTable();
        
        // 2. 玩家加入
        List<TablePlayer> players = addPlayersToTable(table.getId(), 6);
        
        // 3. 开始游戏
        Game game = gameService.startNewGame(table.getId());
        
        // 4. 模拟完整游戏流程
        simulatePreFlop(game);
        simulateFlop(game);
        simulateTurn(game);
        simulateRiver(game);
        simulateShowdown(game);
        
        // 5. 验证结果
        Game finishedGame = gameRepository.findById(game.getId());
        assertEquals(GameStatus.FINISHED, finishedGame.getStatus());
        
        // 6. 验证筹码变化
        verifyChipDistribution(players, finishedGame);
    }
}
```

---

## 10. 安全考虑

### 10.1 防作弊机制

1. **发牌安全**
   - 使用加密级随机数生成器
   - 记录洗牌种子，支持事后验证
   - 底牌加密存储

2. **操作验证**
   - 服务端验证所有玩家操作
   - 防止客户端篡改
   - 操作时间窗口限制

3. **数据完整性**
   - 关键数据数字签名
   - 游戏记录不可篡改
   - 定期数据一致性检查

### 10.2 权限控制

```java
@PreAuthorize("hasRole('CLUB_ADMIN') or @clubService.isMember(#clubId, authentication.name)")
public CashTable createTable(@PathVariable Long clubId, @RequestBody CreateTableRequest request) {
    // 创建赛事逻辑
}

@PreAuthorize("@tableService.isPlayerInTable(#tableId, authentication.name)")
public void playerAction(@PathVariable Long tableId, @RequestBody PlayerActionRequest action) {
    // 玩家操作逻辑
}
```

---

## 结语

本文档详细描述了德州扑克现金赛系统的设计方案，涵盖了从核心发牌算法到完整业务流程的各个方面。开发过程中应严格按照阶段规划进行，确保每个阶段的交付质量，为后续开发奠定坚实基础。

**下一步行动：**
1. ✅ 确认技术方案
2. 🎯 开始第一阶段：核心发牌功能开发
3. 📊 建立项目管理和进度跟踪机制
4. 🧪 制定详细的测试计划

---

*文档版本：v1.0*  
*最后更新：2025-10-14*  
*作者：开发团队*
